# 服务程序的调度

## linux信号的基础知识和使用方法

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

// 信号处理函数
void handler(int sig)
{
    printf("接收到信号：%d\n", sig);
}

// 时钟信号处理函数
void alarmfunc(int num)
{
    printf("接收到了%d时钟信号 \n", num);
    alarm(3);       // 在处理函数中新增这样一行代码，就可以实现没3s闹钟触发一次，而不是之前的只闹一次
}

int main()
{
    for(int i = 1; i < 64; i++)
    {
        signal(i, handler);     // 捕获全部的64个信号量，并使用handler函数进行处理
    }

    signal(15, SIG_IGN);    // 将15这个信号设置为忽略

    signal(15, SIG_DFL);    // 将15这个信号量设置为系统缺省动作

    signal(SIGALRM, alarmfunc);     // 捕获时钟信号，并用时钟信号处理函数进行处理

    alarm(3);   // 设置一个闹钟（3s后触发闹钟），本闹钟是一次性闹钟

    while(1)
    {
        printf("执行了一次任务 \n");
        sleep(1);
    }
}
```

闹钟信号处理函数中不添加 ` alarm(3);`时，闹钟只响一次

![](.\img\QQ截图20220323085557.png)

闹钟信号处理函数中添加 `alarm(3);`后，闹钟没3s就会发送一次闹钟信号。

![](.\img\QQ截图20220323085847.png)



```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

// 信号处理函数
void EXIT(int sig)
{
    printf("接收到信号：%d, 程序即将退出\n", sig);

    // 程序退出善后代码
    exit(0);
}

// 时钟信号处理函数
void alarmfunc(int num)
{
    printf("接收到了%d时钟信号 \n", num);
    alarm(3);       // 在处理函数中新增这样一行代码，就可以实现没3s闹钟触发一次，而不是之前的只闹一次
}

int main()
{
    for(int i = 1; i < 64; i++)
    {
        signal(i, SIG_IGN);     // 捕获全部的64个信号量，并将这些进行忽略
    }

    // 设置信号 2 和 信号15 的处理函数,该处理函数命名为EXIT
    signal(SIGINT, EXIT);
    signal(SIGTERM, EXIT);

    while(1)
    {
        printf("执行了一次任务 \n");
        sleep(1);
    }
}
```

![](.\img\QQ截图20220323091211.png)

## linux多进程的基础知识和使用方法

## 开发服务程序调度模块

