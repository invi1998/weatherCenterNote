# 守护进程的实现

## linux共享内存的基础知识和使用方法

linux系统中，每个进程的内存空间是独立的，互相之间不能相互访问，共享内存允许多个进程访问一个公共内存，是进程之间共享和传递数据最高效的方式，没有之一。共享内存的操作比较简单，只有4个动作。

1. 调用shmget函数获取或者创建共享内存。如果共享内存不存在，就创建它，如果已经存在就获取它的地址。
2. 调用shmat函数把共享内存连接到当亲进程的地址空间。然后当前进程就可以
3. 调用shmdt函数把共享内存从当前进程中分离。如果当前进程不再需要这块共享内存了，比如进程要退出了，就可以调用shmdt函数把当前进程从共享内存中分离
4. 调用shmctl函数删除共享内存。共享内存创建了，一般不删除，除非整个项目的服务程序都停止运行。

共享内存需要包含如下两个头文件

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
```

### shmget

```c++
SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

```

- 第一个参数 key ，在进程通信中，不管是消息队列，共享内存 还是 信号量。每个对象都有一个key。不同的进程通过key来识别不同的对象。key是一个整数，通常用16进制来表示。
- 第二个参数是共享内存的大小
- 第三个参数是共享内存的标志。用于填写操作权限和其他的标志。

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    return 0;
}
```

编译运行，然后使用 `ipcs -m` 这个命令查看共享内存

![](./img/QQ截图20220323225613.png)

各个字段信息如下：

- key：共享内存key
- shmid：共享内存ID
- owner：拥有者
- perms：权限
- bytes：字节大小
- nattch：当前共享内存被多少个进程使用了（连接）
- status：状态

关于这里shmget函数里第一个参数为什么要使用16进制，是因为从 `ipcs -m`这个命令可以看到，共享内存的key它是一个16进制的表示，如果我们一开始就用十进制来做参数，那么在查看共享内存的时候，key的这个值会别转换成16进制，前后之间不好理解，可读性较差，所以不如直接就在一开始使用功能16进制作为参数传递进get函数

然后使用 `ipcrm -m 共享内存shmid` 可以删除共享内存，参数就是这个共享内存的shmid

![](./img/QQ截图20220323230431.png)

### shmat 和 shmdt

```shell
SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);

```

shmat这个函数就是把共享内存连接到当前进程的地址空间。shmdt就是将共享内存从当前进程的地址空间分离出去。

- shemat它的第一个参数是共享内存的shmid
- 他的第二个参数 和 第三个参数都可以填 0 ，而且一般也都是填 0
- 然后shemat 函数的返回值就是共享内存的地址。在程序中我们使用一个指针来指向这个地址，操作共享内存就像操作本地变量一样方便。

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    // 先定义一个指针变量用于存放 shmat 函数的返回地址。（用于指向共享内存的结构体白能量指针）
    struct st_pid* stpid = nullptr;     // 初始化为 0 或者 NULL 或者在c++11中可以初始化为 nullptr

    // 通常来说，只要shmid 共享内存id没有填错，一般shmat是不会失败的，如果失败会返回 -1
    // 注意，这里shmat的返回值需要强制转换成你需要的类型，同时后面的判断条件 -1 也需要强制转换成 （void *)，因为shmat这个函数他的返回值类型是 一个(void *)指针类型
    if((stpid = (struct st_pid*)shmat(shmid, 0, 0)) == (void *)-1)
    {
        printf("shmat(shmid, 0, 0) faild \n");
    }

    // 然后就可以像使用普通的指针一样使用共享内存了

    // 在赋值之前我们先把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);

    stpid->pid = getpid();              // 把当前进程的id赋给共享内存的pid成员
    // strcpy(stpid->name, argv[0]);       // 然后把当前进程（程序）的名称赋给共享内存的name成员
    strcpy(stpid->name, argv[1]);       // 然后把当前进程（程序）的第一个参数赋给共享内存的name成员

    // 在赋值之后我们也把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);


    // 把共享内存从当前进程中分离
    // shmdt 这个函数他的参数就是上面这里这个指针变量 stpid 指向的内存地址
    // 只要这个指针变量他的内存地址没有问题，那么shmdt这个函数肯定不会失败，所以这里不用判断他的返回值
    shmdt(stpid);

    return 0;
}
```

然后我们编译运行这个程序

![](./img/QQ截图20220323233202.png)

我们分别运行了3次，第一次运行，因为共享内存刚创建，数据为空，所以打印成员值为空，然后我们把进程id和参数aaa写入到共享内存

然后第二次运行，因为共享内存在上次运行的时候已经被创建了，所以这里共享内存里面已经保存了上次存入的进程id和aaa字段，所以这里有信息打印，然后我们继续把这次的进程id和参数 bbb 保存进共享内存中

同理，第三次运行也是一样的。

### shmctl

## linux信号量的基础知识和使用方法

## 开发守护进程模块，于调度模块结合，保证服务程序永不停机
