# 守护进程的实现

## linux共享内存的基础知识和使用方法

linux系统中，每个进程的内存空间是独立的，互相之间不能相互访问，共享内存允许多个进程访问一个公共内存，是进程之间共享和传递数据最高效的方式，没有之一。共享内存的操作比较简单，只有4个动作。

1. 调用shmget函数获取或者创建共享内存。如果共享内存不存在，就创建它，如果已经存在就获取它的地址。
2. 调用shmat函数把共享内存连接到当亲进程的地址空间。然后当前进程就可以
3. 调用shmdt函数把共享内存从当前进程中分离。如果当前进程不再需要这块共享内存了，比如进程要退出了，就可以调用shmdt函数把当前进程从共享内存中分离
4. 调用shmctl函数删除共享内存。共享内存创建了，一般不删除，除非整个项目的服务程序都停止运行。

共享内存需要包含如下两个头文件

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
```

### shmget

```c++
SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

```

- 第一个参数 key ，在进程通信中，不管是消息队列，共享内存 还是 信号量。每个对象都有一个key。不同的进程通过key来识别不同的对象。key是一个整数，通常用16进制来表示。
- 第二个参数是共享内存的大小
- 第三个参数是共享内存的标志。用于填写操作权限和其他的标志。

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    return 0;
}
```

编译运行，然后使用 `ipcs -m` 这个命令查看共享内存

![](./img/QQ截图20220323225613.png)

各个字段信息如下：

- key：共享内存key
- shmid：共享内存ID
- owner：拥有者
- perms：权限
- bytes：字节大小
- nattch：当前共享内存被多少个进程使用了（连接）
- status：状态

关于这里shmget函数里第一个参数为什么要使用16进制，是因为从 `ipcs -m`这个命令可以看到，共享内存的key它是一个16进制的表示，如果我们一开始就用十进制来做参数，那么在查看共享内存的时候，key的这个值会别转换成16进制，前后之间不好理解，可读性较差，所以不如直接就在一开始使用功能16进制作为参数传递进get函数

然后使用 `ipcrm -m 共享内存shmid` 可以删除共享内存，参数就是这个共享内存的shmid

![](./img/QQ截图20220323230431.png)

### shmat 和 shmdt

```shell
SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);

       int shmdt(const void *shmaddr);

```

shmat这个函数就是把共享内存连接到当前进程的地址空间。shmdt就是将共享内存从当前进程的地址空间分离出去。

- shemat它的第一个参数是共享内存的shmid
- 他的第二个参数 和 第三个参数都可以填 0 ，而且一般也都是填 0
- 然后shemat 函数的返回值就是共享内存的地址。在程序中我们使用一个指针来指向这个地址，操作共享内存就像操作本地变量一样方便。

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    // 先定义一个指针变量用于存放 shmat 函数的返回地址。（用于指向共享内存的结构体白能量指针）
    struct st_pid* stpid = nullptr;     // 初始化为 0 或者 NULL 或者在c++11中可以初始化为 nullptr

    // 通常来说，只要shmid 共享内存id没有填错，一般shmat是不会失败的，如果失败会返回 -1
    // 注意，这里shmat的返回值需要强制转换成你需要的类型，同时后面的判断条件 -1 也需要强制转换成 （void *)，因为shmat这个函数他的返回值类型是 一个(void *)指针类型
    if((stpid = (struct st_pid*)shmat(shmid, 0, 0)) == (void *)-1)
    {
        printf("shmat(shmid, 0, 0) faild \n");
    }

    // 然后就可以像使用普通的指针一样使用共享内存了

    // 在赋值之前我们先把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);

    stpid->pid = getpid();              // 把当前进程的id赋给共享内存的pid成员
    // strcpy(stpid->name, argv[0]);       // 然后把当前进程（程序）的名称赋给共享内存的name成员
    strcpy(stpid->name, argv[1]);       // 然后把当前进程（程序）的第一个参数赋给共享内存的name成员

    // 在赋值之后我们也把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);


    // 把共享内存从当前进程中分离
    // shmdt 这个函数他的参数就是上面这里这个指针变量 stpid 指向的内存地址
    // 只要这个指针变量他的内存地址没有问题，那么shmdt这个函数肯定不会失败，所以这里不用判断他的返回值
    shmdt(stpid);

    return 0;
}
```

然后我们编译运行这个程序

![](./img/QQ截图20220323233202.png)

我们分别运行了3次，第一次运行，因为共享内存刚创建，数据为空，所以打印成员值为空，然后我们把进程id和参数aaa写入到共享内存

然后第二次运行，因为共享内存在上次运行的时候已经被创建了，所以这里共享内存里面已经保存了上次存入的进程id和aaa字段，所以这里有信息打印，然后我们继续把这次的进程id和参数 bbb 保存进共享内存中

同理，第三次运行也是一样的。

### shmctl

```shell
SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmctl(int shmid, int cmd, struct shmid_ds *buf);
       
DESCRIPTION
       shmctl() performs the control operation specified by cmd on the System V shared memory segment whose identifier is given in shmid.

       The buf argument is a pointer to a shmid_ds structure, defined in <sys/shm.h> as follows:

           struct shmid_ds {
               struct ipc_perm shm_perm;    /* Ownership and permissions */
               size_t          shm_segsz;   /* Size of segment (bytes) */
               time_t          shm_atime;   /* Last attach time */
               time_t          shm_dtime;   /* Last detach time */
               time_t          shm_ctime;   /* Creation time/time of last
                                               modification via shmctl() */
               pid_t           shm_cpid;    /* PID of creator */
               pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
               shmatt_t        shm_nattch;  /* No. of current attaches */
               ...
           };

```

共享内存的 shmctl 函数，可以用于删除共享内存，也可以用于做更多复杂的操作。

1. 第一个参数shmid：是共享内存的id
2. 第二个参数是想要执行的操作的命令
3. 第三个参数是一个结构体。共享内存在系统中有一个结构体，这个结构体包含了共享内存更多更详细的信息。一般来说，程序员不需要对这个结构体过度关心。用这个函数更多的是用于删除共享内存

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    // 先定义一个指针变量用于存放 shmat 函数的返回地址。（用于指向共享内存的结构体白能量指针）
    struct st_pid* stpid = nullptr;     // 初始化为 0 或者 NULL 或者在c++11中可以初始化为 nullptr

    // 通常来说，只要shmid 共享内存id没有填错，一般shmat是不会失败的，如果失败会返回 -1
    // 注意，这里shmat的返回值需要强制转换成你需要的类型，同时后面的判断条件 -1 也需要强制转换成 （void *)，因为shmat这个函数他的返回值类型是 一个(void *)指针类型
    if((stpid = (struct st_pid*)shmat(shmid, 0, 0)) == (void *)-1)
    {
        printf("shmat(shmid, 0, 0) faild \n");
    }

    // 然后就可以像使用普通的指针一样使用共享内存了

    // 在赋值之前我们先把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);

    stpid->pid = getpid();              // 把当前进程的id赋给共享内存的pid成员
    // strcpy(stpid->name, argv[0]);       // 然后把当前进程（程序）的名称赋给共享内存的name成员
    strcpy(stpid->name, argv[1]);       // 然后把当前进程（程序）的第一个参数赋给共享内存的name成员

    // 在赋值之后我们也把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);


    // 把共享内存从当前进程中分离
    // shmdt 这个函数他的参数就是上面这里这个指针变量 stpid 指向的内存地址
    // 只要这个指针变量他的内存地址没有问题，那么shmdt这个函数肯定不会失败，所以这里不用判断他的返回值
    shmdt(stpid);

    // 删除共享内存
    // 如果删除失败，返回-1
    if(shmctl(shmid, IPC_RMID, 0) == -1)
    {
        printf("shmctl(stpid, IPC_RMID, 0) faild \n");
    }

    return 0;
}
```

可以看到，在添加了shmctl函数之后，我们每次都会将共享内存进行删除，所以 `ipcs -m`指令就找不到该共享内存了

![](./img/QQ截图20220324145756.png)

## linux信号量的基础知识和使用方法

要想让程序安全地执行，就要有一种进程同步的进制，保证在进入临界区的操作是原子操作。例如，可以使用接下来所讲的信号量来进行进程的同步。因为信号量的操作都是原子性的。

使用共享内存的优缺点

1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

针对共享内存这个麻烦，如果有一个进程正在往共享内存中写入数据，在没有写入完成之前，是不应该让其他进程访问该共享内存的，共享内存没有提供锁机制，所以需要使用信号量来为共享内存加锁

- 信号量本质上是一个非负数（>= 0）的计数器
- 用于给共享资源建立一个标志，表示该共享资源被占用的情况
- 进程对信号量有两个操作： p操作（申请资源 -1），V操作（释放资源 +1）
- 二值信号量是信号量的一种特殊形式，表示资源只有可用和不可用两种状态：0 不可用， 1 可用，他的功能与互斥锁相同，只有开和关两种状态

对p v 操作举个例子：

![](./img/QQ截图20220324150743.png)

```c++
// 信号量。
class CSEM
{
private:
  union semun  // 用于信号量操作的共同体。
  {
    int val;
    struct semid_ds *buf;
    unsigned short  *arry;
  };

  int   m_semid;         // 信号量描述符。

  // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，
  // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢
  // 复为初始值（就像撤消了全部进程对信号的操作）。
  // 如果信号量用于表示可用资源的数量（不变的），设置为SEM_UNDO更合适。
  // 如果信号量用于生产消费者模型，设置为0更合适。
  // 注意，网上查到的关于sem_flg的用法基本上是错的，一定要自己动手多测试。
  short m_sem_flg;
public:
  CSEM();
  // 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。
  bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO); 
  bool P(short sem_op=-1); // 信号量的P操作。
  bool V(short sem_op=1);  // 信号量的V操作。
  int  value();            // 获取信号量的值，成功返回信号量的值，失败返回-1。
  bool destroy();          // 销毁信号量。
 ~CSEM();
};
```

然后我们采用信号量给上面那个demo程序加锁

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "_public.h"

// 创建一个信号量对象，用于给共享内存加锁
CSEM sem;

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    // 初始化信号量，第一个参数key：是和信号量那个key是一样的，也是一个十六进制数，注意这里这个key也可以使用共享内存那个key,他们两个是独立的，互不冲突
    // 第二个参数：value 表示信号量的初始值，而知信号量的初始值缺省为1
    // 第三个参数，信号量的标志 如果是二值信号量的化就是 SEM_UNDO 也是缺省的 
    // （所以可以看出，我们提供的这个CSEM 信号量类，默认情况下是一个二值信号量）
    // 如果信号量已经存在，获取信号信号量，如果不存在，则创建它并初始化为value
    if(sem.init(0x5005) == false)
    {
        printf("sem.init(0x5005) faild \n");
        return -1;
    }

    // 然后编写加锁和解锁的代码

    // 先定义一个指针变量用于存放 shmat 函数的返回地址。（用于指向共享内存的结构体白能量指针）
    struct st_pid* stpid = nullptr;     // 初始化为 0 或者 NULL 或者在c++11中可以初始化为 nullptr

    // 通常来说，只要shmid 共享内存id没有填错，一般shmat是不会失败的，如果失败会返回 -1
    // 注意，这里shmat的返回值需要强制转换成你需要的类型，同时后面的判断条件 -1 也需要强制转换成 （void *)，因为shmat这个函数他的返回值类型是 一个(void *)指针类型
    if((stpid = (struct st_pid*)shmat(shmid, 0, 0)) == (void *)-1)
    {
        printf("shmat(shmid, 0, 0) faild \n");
    }
    // 然后就可以像使用普通的指针一样使用共享内存了

    // 在加锁之前将当前时间 和 信号量的值显示出来
    printf("start  time = %ld， value = %d \n", time(0), sem.value());

    sem.P();        // 加锁

    // 在加锁之后将当前时间 和 信号量的值显示出来
    printf("start  time = %ld， value = %d \n", time(0), sem.value());

    // 在赋值之前我们先把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);

    stpid->pid = getpid();              // 把当前进程的id赋给共享内存的pid成员
    // strcpy(stpid->name, argv[0]);       // 然后把当前进程（程序）的名称赋给共享内存的name成员
    strcpy(stpid->name, argv[1]);       // 然后把当前进程（程序）的第一个参数赋给共享内存的name成员

    // 在赋值之后我们也把共享内存里面的东西读出来
    printf("pid = %d， name = %s \n", stpid->pid, stpid->name);
    sleep(10);

    // 在解锁之前将当前时间 和 信号量的值显示出来
    printf("end  time = %ld， value = %d \n", time(0), sem.value());

    sem.V();        // 解锁

    // 在解锁之后将当前时间 和 信号量的值显示出来
    printf("end  time = %ld， value = %d \n", time(0), sem.value());


    // 把共享内存从当前进程中分离
    // shmdt 这个函数他的参数就是上面这里这个指针变量 stpid 指向的内存地址
    // 只要这个指针变量他的内存地址没有问题，那么shmdt这个函数肯定不会失败，所以这里不用判断他的返回值
    shmdt(stpid);

    // 删除共享内存
    // 如果删除失败，返回-1
    if(shmctl(shmid, IPC_RMID, 0) == -1)
    {
        printf("shmctl(stpid, IPC_RMID, 0) faild \n");
    }

    return 0;
}
```

然后我们编译运行，查看运行结果

![](./img/QQ截图20220325092119.png)

说明：第一行打印，是信号量加锁之前，因为信号量初始化为1，然后接下来执行加锁 （P操作），P操作会将信号量的值-1，所以这里加锁之后的打印，信号量就变成了0。然后，sleep 10秒之后，因为没有进行V操作，锁还在持有中，信号量的值还是0，不变，所以打印出来也就是0。然后执行解锁（V操作）。V操作会将信号量进行的值+1.所以这里信号量的值变成了1.

![](./img/QQ截图20220325092653.png)

使用 `ipcs -s` 命令可以查看信号量。

- key：信号量key
- semid：信号量的id
- owner：信号量拥有者
- perms：权限
- nsems：信号量个数

![](./img/QQ截图20220325093020.png)

使用 `ipcrm sem 信号量id` 这个指令，可以用于删除信号量，删除成功会提示资源以删除（resource(s) deleted）

然后继续我们上面的代码，我们启动4个终端，分别运行这个book测试程序，运行结果如下：

![](./img/QQ截图20220325094332.png)

可以看到一个很奇怪的现象，就是输出结果并没有像我们单独运行一个程序的时候那样，信号量的值是1 0 0 1，而是变成了 1 0 0 0 ，0 0 0 0 ， 0 0 0 0 ， 0 0 0 1

这是为什么？

首先看第一个，它在39s的时候，对信号量进行加锁操作（p)，这个时候，信号量的值由1变成0，打印也是 1 0，然后继续sleep10s,依旧持有锁，这个时候，它进行解锁（v)，它将信号量的值-1，**同时唤醒下一个在等待加锁的进程**，这个时候，bbb 进程被唤醒，执行P操作（加锁），它就会将这个信号量再进行-1操作，所以这个时候在第二个 bbb 程序这里，信号量又变成了0。这里需要特别注意一个点，我们上面说，**同时** 而不是在某一步之后，这个唤醒加锁的动作和前一个锁释放（v操作）是同时完成的。因为这几部操作是原子操作，所以依托原子操作之后，原来解锁之后又唤醒又加锁，信号量就又变成了0，所以在第一个终端里打印的解锁之后的信号量的值其实是第二个终端页面已经加锁了的信号量的值。所以才是0而不是1。也就是说

```c++
    sem.V();        // 解锁

    // 在解锁之后将当前时间 和 信号量的值显示出来
    printf("end  time = %ld， value = %d \n", time(0), sem.value());

```

这个打印虽然是紧跟着V操作，但是因为信号量的原子特性，这个时候这个打印看到的信号量是0。之后的这几个bash也是类似的道理。至于最后这个，因为到这个进程的时候，信号量排队队列中，已经没有进程了，所以没有下一个进程需要来获取锁加锁，也就是没有下一个进程来讲信号量-1了，所以这个时候就打印的是1。很好理解

## 开发守护进程模块，于调度模块结合，保证服务程序永不停机
