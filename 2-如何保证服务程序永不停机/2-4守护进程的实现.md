# 守护进程的实现

## linux共享内存的基础知识和使用方法

linux系统中，每个进程的内存空间是独立的，互相之间不能相互访问，共享内存允许多个进程访问一个公共内存，是进程之间共享和传递数据最高效的方式，没有之一。共享内存的操作比较简单，只有4个动作。

1. 调用shmget函数获取或者创建共享内存。如果共享内存不存在，就创建它，如果已经存在就获取它的地址。
2. 调用shmat函数把共享内存连接到当亲进程的地址空间。然后当前进程就可以
3. 调用shmdt函数把共享内存从当前进程中分离。如果当前进程不再需要这块共享内存了，比如进程要退出了，就可以调用shmdt函数把当前进程从共享内存中分离
4. 调用shmctl函数删除共享内存。共享内存创建了，一般不删除，除非整个项目的服务程序都停止运行。

共享内存需要包含如下两个头文件

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
```

### shmget

```c++
SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

```

- 第一个参数 key ，在进程通信中，不管是消息队列，共享内存 还是 信号量。每个对象都有一个key。不同的进程通过key来识别不同的对象。key是一个整数，通常用16进制来表示。
- 第二个参数是共享内存的大小
- 第三个参数是共享内存的标志。用于填写操作权限和其他的标志。

```c++
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct st_pid
{
    int pid;        // 进程编号
    char name[51];  // 进程名称
};

int main(int argc, char* argv[])
{
    // 共享内存标志
    int shmid;

    // 这个共享内存，第一个参数
    // 第二个参数，这里我打算用这个共享内存来保存一个结构体，所以这里内存大小设置为结构体的size值
    // 然后第三个参数，我们一般这么写 0640|IPC_CREAT 
    // 它包括两个部分，前面这部分是操作权限，他的表示方法跟文件和目录的表示方法是一样的（八进制）
    // 第二部分（IPC_CREAT）表示如果共享内存已经存在，就获得他的id，如果不存在就创建它（这部分参数基本上没有选择，只能填这个）
    // shmget函数，成功返回共享内存的id，失败返回-1，系统错误变量并设置，一般来说，如果不是因为系统内存不够，很少会返回失败
    if((shmid = shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT)) == -1)
    {
        printf("shmget(0x5005, sizeof(struct st_pid), 0640|IPC_CREAT) faild \n");
    }

    return 0;
}
```

编译运行，然后使用 `ipcs -m` 这个命令查看共享内存

![](./img/QQ截图20220323225613.png)

各个字段信息如下：

- key：共享内存key
- shmid：共享内存ID
- owner：拥有者
- perms：权限
- bytes：字节大小
- nattch：当前共享内存被多少个进程使用了（连接）
- status：状态

关于这里shmget函数里第一个参数为什么要使用16进制，是因为从 `ipcs -m`这个命令可以看到，共享内存的key它是一个16进制的表示，如果我们一开始就用十进制来做参数，那么在查看共享内存的时候，key的这个值会别转换成16进制，前后之间不好理解，可读性较差，所以不如直接就在一开始使用功能16进制作为参数传递进get函数

然后使用 `ipcrm -m 共享内存shmid` 可以删除共享内存，参数就是这个共享内存的shmid

![](./img/QQ截图20220323230431.png)

## linux信号量的基础知识和使用方法

## 开发守护进程模块，于调度模块结合，保证服务程序永不停机
