# 刷新同步数据模块

- 全表刷新，使用于数据量不大的表，能保证数据的完整性
- 分批刷新，适用于数据量比较大的表，不能保证数据的完整性

建表1

```sql
drop table if exists T_ZHOBTCODE2;

/*==============================================================*/
/* Table: T_ZHOBTCODE2                                          */
/*==============================================================*/
create table T_ZHOBTCODE2
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE2_KEYID (keyid)
);

alter table T_ZHOBTCODE2 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```

建表2

```sql
drop table if exists T_ZHOBTCODE3;

/*==============================================================*/
/* Table: T_ZHOBTCODE3                                          */
/*==============================================================*/
create table T_ZHOBTCODE3
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE3_id (keyid)
);

alter table T_ZHOBTCODE3 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```

创建远程表 T_ZHOBTCODE1 的映射（federated）表 LK_ZHOBTCODE1

```sql
drop table if exists LK_ZHOBTCODE1;

/*==============================================================*/
/* Table: T_ZHOBTCODE1                                          */
/*==============================================================*/
create table LK_ZHOBTCODE1
(
   obtid                varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) not null comment '省名称',
   lat                  int not null comment '纬度，单位：0.01度。',
   lon                  int not null comment '经度，单位：0.01度。',
   height               int not null comment '海拔高度，单位：0.1米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (obtid),
   unique key ZHOBTCODE1_KEYID (keyid)
)engine=FEDERATED CONNECTION='mysql://root:psaaword@192.168.31.133:3306/mysql/T_ZHOBTCODE1';
```

## 刷新同步-分批刷新

大致流程如下

1. 从远程表中查询需要同步的数据，把结果集分成若干批，每批的记录数在50-256之间
2. 删除本地表中指定批的记录
3. 把federated表中指定批的记录插入本地表

分批刷新同步的流程需要一个循环，在循环里面执行第二步和第三步，直到全部的数据被处理完。

其次，从远程表查询需要同步的数据，而不是federated表。为什么？一是federated表不支持普通索引，如果同步的条件不是主键，也不是唯一键，就会进行全表扫描，二是就算federated表支持索引，效率也不如直接访问远程表的效率高

```c++
// 业务处理主函数。
bool _syncupdate()
{
    CTimer Timer;

    sqlstatement stmtdel(&connloc);     // 执行删除本地表中记录的sql语句
    sqlstatement stmtins(&connloc);     // 执行向本地表中插入数据的sql语句

    // 如果是不分批同步，表示需要同步的数据量较少，执行一次sql语句就可以搞定（全表刷新）
    if(starg.synctype == 1)
    {
        logfile.Write("sync %s to %s ....", starg.fedtname, starg.localtname);

        // 先删除starg.localtname表中满足where条件的记录
        stmtdel.prepare("delete from %s %s", starg.localtname, starg.where);
        if(stmtdel.execute() != 0)
        {
            logfile.Write("stmtdel.execute() failed\n%s\n%s\n", stmtdel.m_sql, stmtdel.m_cda.message);
            return false;
        }
        // 再把starg.fedtname表中满足where条件的记录插入到starg.localname表中
        stmtins.prepare("insert into %s(%s) select %s from %s %s", starg.localtname, starg.localcols, starg.remotecols, starg.fedtname, starg.where);
        if(stmtins.execute() != 0)
        {
            // 如果执行插入sql失败，那么应该回滚事务
            connloc.rollback();

            logfile.Write("stmtins.execute() failed\n%s\n%s\n", stmtins.m_sql, stmtins.m_cda.message);

            return false;
        }
        
        logfile.WriteEx("   %d rows in %.2f sec\n", stmtins.m_cda.rpc, Timer.Elapsed());

        connloc.commit();   // 提交事务
        return true;
    }

    return true;
}
```

如下图所示是我们手工同步需要执行的sql语句。在项目开发过程中，其实要拼接执行的sql语句也就是这样

![](./img/QQ截图20220420202342.png)

这里对同步刷新（全表刷新）做一下测试。编译运行，先看无条件同步（下图中分别执行了两次程序，第一次是无条件全表同步，第二次可以看到我们带了where条件语句，值同步广东省的站点参数）

![](./img/QQ截图20220420202242.png)

然后看执行日志，可以看到全表800多条记录全部被同步进t_zhobtcode2表中

![](./img/QQ截图20220420201917.png)

查看表结果

![](./img/QQ截图20220420201824.png)

然后再看条件同步的结果，先看日志

![](./img/QQ截图20220420202214.png)

然后是同步结果，可以看到，确实只有广东的站点数据被同步了

![](./img/QQ截图20220420202300.png)

```c++
// 程序名：syncupdate.cpp，本程序是数据中心的公共功能模块，采用刷新的方法同步MySQL数据库之间的表。

#include "_tools.h"

struct st_arg
{
  char localconnstr[101];  // 本地数据库的连接参数。
  char charset[51];        // 数据库的字符集。
  char fedtname[31];       // Federated表名。
  char localtname[31];     // 本地表名。
  char remotecols[1001];   // 远程表的字段列表。
  char localcols[1001];    // 本地表的字段列表。
  char where[1001];        // 同步数据的条件。
  int  synctype;           // 同步方式：1-不分批同步；2-分批同步。
  char remoteconnstr[101]; // 远程数据库的连接参数。
  char remotetname[31];    // 远程表名。
  char remotekeycol[31];   // 远程表的键值字段名。
  char localkeycol[31];    // 本地表的键值字段名。
  int  maxcount;           // 每批执行一次同步操作的记录数。
  int  timeout;            // 本程序运行时的超时时间。
  char pname[51];          // 本程序运行时的程序名。
} starg;

CLogFile logfile;
connection connloc;   // 本地数据库连接。
connection connrem;   // 远程数据库连接。
CPActive PActive;

// 业务处理主函数。
bool _syncupdate();

// 显示程序的帮助
void _help(char *argv[]);

// 把xml解析到参数starg结构中
bool _xmltoarg(char *strxmlbuffer);

void EXIT(int sig);

int main(int argc,char *argv[])
{
    if (argc!=3) { _help(argv); return -1; }

    // 关闭全部的信号和输入输出，处理程序退出的信号。
    CloseIOAndSignal();
    signal(SIGINT,EXIT); signal(SIGTERM,EXIT);

    if (logfile.Open(argv[1],"a+")==false)
    {
        printf("打开日志文件失败（%s）。\n",argv[1]); return -1;
    }

    // 把xml解析到参数starg结构中
    if (_xmltoarg(argv[2])==false) return -1;

    PActive.AddPInfo(starg.timeout,starg.pname);
    // 注意，在调试程序的时候，可以启用类似以下的代码，防止超时。
    // PActive.AddPInfo(starg.timeout*100,starg.pname);

    if (connloc.connecttodb(starg.localconnstr,starg.charset) != 0)
    {
        logfile.Write("connect database(%s) failed.\n%s\n",starg.localconnstr,connloc.m_cda.message); EXIT(-1);
    }

    // logfile.Write("connect database(%s) ok.\n",starg.localconnstr);

    // 如果starg.remotecols或者starg.localcols为空。就用starg.localtname表的全部列来填充
    if(strlen(starg.remotecols) == 0 || strlen(starg.localcols) == 0)
    {
        CTABCOLS tablecols;

        if(tablecols.allcols(&connloc, starg.localtname) == false)
        {
            logfile.Write("表%s不存在\n", starg.localtname);
            EXIT(-1);
        }

        if(strlen(starg.remotecols) == 0)
        {
            strcpy(starg.remotecols, tablecols.m_allcols);
        }

        if(strlen(starg.localcols) == 0)
        {
            strcpy(starg.localcols, tablecols.m_allcols);
        }
    }

    // 业务处理主函数。
    _syncupdate();

}

// 显示程序的帮助
void _help(char *argv[])
{
    printf("Using:/project/tools/bin/syncupdate logfilename xmlbuffer\n\n");

    printf("Sample:/project/tools/bin/procctl 10 /project/tools/bin/syncupdate /log/idc/syncupdate_ZHOBTCODE2.log \"<localconnstr>192.168.31.133,root,psaaword,mysql,3306</localconnstr><charset>utf8</charset><fedtname>LK_ZHOBTCODE1</fedtname><localtname>T_ZHOBTCODE2</localtname><remotecols>obtid,cityname,provname,lat,lon,height/10,upttime,keyid</remotecols><localcols>stid,cityname,provname,lat,lon,altitude,upttime,keyid</localcols><synctype>1</synctype><timeout>50</timeout><pname>syncupdate_ZHOBTCODE2</pname>\"\n\n");

    // 因为测试的需要，xmltodb程序每次会删除LK_ZHOBTCODE1中的数据，全部的记录重新入库，keyid会变。
    // 所以以下脚本不能用keyid，要用obtid，用keyid会出问题，可以试试。
    printf("       /project/tools/bin/procctl 10 /project/tools/bin/syncupdate /log/idc/syncupdate_ZHOBTCODE3.log \"<localconnstr>192.168.31.133,root,psaaword,mysql,3306</localconnstr><charset>utf8</charset><fedtname>LK_ZHOBTCODE1</fedtname><localtname>T_ZHOBTCODE3</localtname><remotecols>obtid,cityname,provname,lat,lon,height/10,upttime,keyid</remotecols><localcols>stid,cityname,provname,lat,lon,altitude,upttime,keyid</localcols><where>where obtid like '54%%%%'</where><synctype>2</synctype><remoteconnstr>192.168.31.133,root,psaaword,mysql,3306</remoteconnstr><remotetname>T_ZHOBTCODE1</remotetname><remotekeycol>obtid</remotekeycol><localkeycol>stid</localkeycol><maxcount>10</maxcount><timeout>50</timeout><pname>syncupdate_ZHOBTCODE3</pname>\"\n\n");

    printf("       /project/tools/bin/procctl 10 /project/tools/bin/syncupdate /log/idc/syncupdate_ZHOBTMIND2.log \"<localconnstr>192.168.31.133,root,psaaword,mysql,3306</localconnstr><charset>utf8</charset><fedtname>LK_ZHOBTMIND1</fedtname><localtname>T_ZHOBTMIND2</localtname><remotecols>obtid,ddatetime,t,p,u,wd,wf,r,vis,upttime,keyid</remotecols><localcols>stid,ddatetime,t,p,u,wd,wf,r,vis,upttime,recid</localcols><where>where ddatetime>timestampadd(minute,-120,now())</where><synctype>2</synctype><synctype>2</synctype><remoteconnstr>192.168.31.133,root,psaaword,mysql,3306</remoteconnstr><remotetname>T_ZHOBTMIND1</remotetname><remotekeycol>keyid</remotekeycol><localkeycol>recid</localkeycol><maxcount>300</maxcount><timeout>50</timeout><pname>syncupdate_ZHOBTMIND2</pname>\"\n\n");

    printf("本程序是数据中心的公共功能模块，采用刷新的方法同步MySQL数据库之间的表。\n\n");

    printf("logfilename   本程序运行的日志文件。\n");
    printf("xmlbuffer     本程序运行的参数，用xml表示，具体如下：\n\n");

    printf("localconnstr  本地数据库的连接参数，格式：ip,username,password,dbname,port。\n");
    printf("charset       数据库的字符集，这个参数要与远程数据库保持一致，否则会出现中文乱码的情况。\n");

    printf("fedtname      Federated表名。\n");
    printf("localtname    本地表名。\n");

    printf("remotecols    远程表的字段列表，用于填充在select和from之间，所以，remotecols可以是真实的字段，\n"\
            "              也可以是函数的返回值或者运算结果。如果本参数为空，就用localtname表的字段列表填充。\n");
    printf("localcols     本地表的字段列表，与remotecols不同，它必须是真实存在的字段。如果本参数为空，\n"\
            "              就用localtname表的字段列表填充。\n");

    printf("where         同步数据的条件，为空则表示同步全部的记录，填充在delete本地表和select Federated表\n"\
            "              之后，注意：1）where中的字段必须同时在本地表和Federated表中；2）不要用系统时间作\n"\
            "              为条件。\n");

    printf("synctype      同步方式：1-不分批同步；2-分批同步。\n");
    printf("remoteconnstr 远程数据库的连接参数，格式与localconnstr相同，当synctype==2时有效。\n");
    printf("remotetname   远程表名，当synctype==2时有效。\n");
    printf("remotekeycol  远程表的键值字段名，必须是唯一的，当synctype==2时有效。\n");
    printf("localkeycol   本地表的键值字段名，必须是唯一的，当synctype==2时有效。\n");

    printf("maxcount      每批执行一次同步操作的记录数，不能超过MAXPARAMS宏（在_mysql.h中定义），当synctype==2时有效。\n");

    printf("timeout       本程序的超时时间，单位：秒，视数据量的大小而定，建议设置30以上。\n");
    printf("pname         本程序运行时的进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\n\n");
    printf("注意：\n1）remotekeycol和localkeycol字段的选取很重要，如果用了MySQL的自增字段，那么在远程表中数据生成后自增字段的值不可改变，否则同步会失败；\n2）当远程表中存在delete操作时，无法分批同步，因为远程表的记录被delete后就找不到了，无法从本地表中执行delete操作。\n\n\n");

}

// 把xml解析到参数starg结构中
bool _xmltoarg(char *strxmlbuffer)
{
    memset(&starg,0,sizeof(struct st_arg));

    // 本地数据库的连接参数，格式：ip,username,password,dbname,port。
    GetXMLBuffer(strxmlbuffer,"localconnstr",starg.localconnstr,100);
    if (strlen(starg.localconnstr)==0) { logfile.Write("localconnstr is null.\n"); return false; }

    // 数据库的字符集，这个参数要与远程数据库保持一致，否则会出现中文乱码的情况。
    GetXMLBuffer(strxmlbuffer,"charset",starg.charset,50);
    if (strlen(starg.charset)==0) { logfile.Write("charset is null.\n"); return false; }

    // Federated表名。
    GetXMLBuffer(strxmlbuffer,"fedtname",starg.fedtname,30);
    if (strlen(starg.fedtname)==0) { logfile.Write("fedtname is null.\n"); return false; }

    // 本地表名。
    GetXMLBuffer(strxmlbuffer,"localtname",starg.localtname,30);
    if (strlen(starg.localtname)==0) { logfile.Write("localtname is null.\n"); return false; }

    // 远程表的字段列表，用于填充在select和from之间，所以，remotecols可以是真实的字段，也可以是函数
    // 的返回值或者运算结果。如果本参数为空，就用localtname表的字段列表填充。\n");
    GetXMLBuffer(strxmlbuffer,"remotecols",starg.remotecols,1000);

    // 本地表的字段列表，与remotecols不同，它必须是真实存在的字段。如果本参数为空，就用localtname表的字段列表填充。
    GetXMLBuffer(strxmlbuffer,"localcols",starg.localcols,1000);

    // 同步数据的条件，即select语句的where部分。
    GetXMLBuffer(strxmlbuffer,"where",starg.where,1000);

    // 同步方式：1-不分批同步；2-分批同步。
    GetXMLBuffer(strxmlbuffer,"synctype",&starg.synctype);
    if ( (starg.synctype!=1) && (starg.synctype!=2) ) { logfile.Write("synctype is not in (1,2).\n"); return false; }

    if (starg.synctype==2)
    {
        // 远程数据库的连接参数，格式与localconnstr相同，当synctype==2时有效。
        GetXMLBuffer(strxmlbuffer,"remoteconnstr",starg.remoteconnstr,100);
        if (strlen(starg.remoteconnstr)==0) { logfile.Write("remoteconnstr is null.\n"); return false; }

        // 远程表名，当synctype==2时有效。
        GetXMLBuffer(strxmlbuffer,"remotetname",starg.remotetname,30);
        if (strlen(starg.remotetname)==0) { logfile.Write("remotetname is null.\n"); return false; }

        // 远程表的键值字段名，必须是唯一的，当synctype==2时有效。
        GetXMLBuffer(strxmlbuffer,"remotekeycol",starg.remotekeycol,30);
        if (strlen(starg.remotekeycol)==0) { logfile.Write("remotekeycol is null.\n"); return false; }

        // 本地表的键值字段名，必须是唯一的，当synctype==2时有效。
        GetXMLBuffer(strxmlbuffer,"localkeycol",starg.localkeycol,30);
        if (strlen(starg.localkeycol)==0) { logfile.Write("localkeycol is null.\n"); return false; }

        // 每批执行一次同步操作的记录数，不能超过MAXPARAMS宏（在_mysql.h中定义），当synctype==2时有效。
        GetXMLBuffer(strxmlbuffer,"maxcount",&starg.maxcount);
        if (starg.maxcount==0) { logfile.Write("maxcount is null.\n"); return false; }
        if (starg.maxcount>MAXPARAMS) starg.maxcount=MAXPARAMS;
    }

    // 本程序的超时时间，单位：秒，视数据量的大小而定，建议设置30以上。
    GetXMLBuffer(strxmlbuffer,"timeout",&starg.timeout);
    if (starg.timeout==0) { logfile.Write("timeout is null.\n"); return false; }

    // 本程序运行时的进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。
    GetXMLBuffer(strxmlbuffer,"pname",starg.pname,50);
    if (strlen(starg.pname)==0) { logfile.Write("pname is null.\n"); return false; }

    return true;
}

void EXIT(int sig)
{
    logfile.Write("程序退出，sig=%d\n\n",sig);

    connloc.disconnect();

    connrem.disconnect();

    exit(0);
}

// 业务处理主函数。
bool _syncupdate()
{
    CTimer Timer;

    sqlstatement stmtdel(&connloc);     // 执行删除本地表中记录的sql语句
    sqlstatement stmtins(&connloc);     // 执行向本地表中插入数据的sql语句

    // 如果是不分批同步，表示需要同步的数据量较少，执行一次sql语句就可以搞定（全表刷新）
    if(starg.synctype == 1)
    {
        logfile.Write("sync %s to %s ....", starg.fedtname, starg.localtname);

        // 先删除starg.localtname表中满足where条件的记录
        stmtdel.prepare("delete from %s %s", starg.localtname, starg.where);
        if(stmtdel.execute() != 0)
        {
            logfile.Write("stmtdel.execute() failed\n%s\n%s\n", stmtdel.m_sql, stmtdel.m_cda.message);
            return false;
        }
        // 再把starg.fedtname表中满足where条件的记录插入到starg.localname表中
        stmtins.prepare("insert into %s(%s) select %s from %s %s", starg.localtname, starg.localcols, starg.remotecols, starg.fedtname, starg.where);
        if(stmtins.execute() != 0)
        {
            // 如果执行插入sql失败，那么应该回滚事务
            connloc.rollback();

            logfile.Write("stmtins.execute() failed\n%s\n%s\n", stmtins.m_sql, stmtins.m_cda.message);

            return false;
        }
        
        logfile.WriteEx("   %d rows in %.2f sec\n", stmtins.m_cda.rpc, Timer.Elapsed());

        connloc.commit();   // 提交事务
        return true;
    }

    // 分批刷新，适用于数据量较大的表
    
    // 连接远程数据库
    if(connrem.connecttodb(starg.remoteconnstr, starg.charset) != 0)
    {
        logfile.Write("connrem.connecttodb(%s, %s) failed\n%s\n", starg.remoteconnstr, starg.charset, connrem.m_cda.message);
        return false;
    }

    // 从远程表查找需要同步的记录的key字段的值
    char remkeyvalue[51];
    sqlstatement stmtsel(&connrem);
    stmtsel.prepare("select %s from %s %s", starg.remotekeycol, starg.remotetname, starg.where);
    stmtsel.bindout(1, remkeyvalue, 50);

    // 拼接绑定同步sql语句参数的字符串 (:1, :2, :3...:starg.maxcount)
    char bindstr[2001];
    char strtemp[11];

    memset(bindstr, 0, sizeof(bindstr));

    for(int i = 0; i < starg.maxcount; i++)
    {
        memset(strtemp, 0, sizeof(strtemp));

        sprintf(strtemp, ":%lu,", i+1);
        strcat(bindstr, strtemp);
    }
    bindstr[strlen(bindstr) - 1] = 0;       // 删除拼接结束后的最后一个逗号

    char keyvalues[starg.maxcount][51];         // 存放starg.maxcount条记录

    // 准备删除本地表数据的sql语句，一次删除starg.maxcount条记录
    // delete from T_ZHOBTCODE3 where stid in(:1, :2, :3,...:starg.maxcount)
    stmtdel.prepare("delete from %s where %s in (%s)", starg.localtname, starg.localkeycol, bindstr);
    for(int i = 0; i < starg.maxcount; i++)
    {
        stmtdel.bindin(i+1, keyvalues[i], 50);
    }

    // 准备插入本地表数据的sql语句，一次插入starg.maxcount条记录
    // insert into T_ZHOBTCODE3(stid, cityname, provname,lat,lon,altitude,upttime,keyid)
    //                  select obtid,cityname,provname,lat,lon,height/10,keyid from LK_ZHOBTCODE1
    //                      where obtid in (:1,:2,:3);
    stmtins.prepare("insert into %s(%s) select %s from %s where %s in (%s)",starg.localtname,starg.localcols,starg.remotecols,starg.fedtname,starg.remotekeycol,bindstr);
    for (int ii=0;ii<starg.maxcount;ii++)
    {
        stmtins.bindin(ii+1,keyvalues[ii],50);
    }

    memset(keyvalues, 0, sizeof(keyvalues));

    int ccount = 0;     // 记录从结果集中已经获取到的记录数

    if(stmtsel.execute() != 0)
    {
        logfile.Write("stmtsel.execute() failed\n%s\n%s\n", stmtsel.m_sql, stmtsel.m_cda.message);
        return false;
    }

    while (true)
    {
        // 获取需要同步的数据的结果集
        if(stmtsel.next() != 0) break;

        strcpy(keyvalues[ccount], remkeyvalue);

        ccount++;

        // 没starg.maxcount条记录执行一次同步
        if(ccount == starg.maxcount)
        {
            // 从本地表中删除记录
            if(stmtdel.execute() != 0)
            {
                // 执行从本地表中删除记录的操作一般不会出错
                // 如果报错，就肯定是数据库的问题或者同步参数配置不正确，流程不必继续走下去
                logfile.Write("stmtdel.execute() failed\n%s\n%s\n", stmtdel.m_sql, stmtdel.m_cda.message);
                return false;
            }

            // 向本地表中插入记录
            if(stmtins.execute() != 0)
            {
                // 执行从本地表中插入记录的操作一般不会出错
                // 如果报错，就肯定是数据库的问题或者同步参数配置不正确，流程不必继续走下去
                logfile.Write("stmtins.execute() failed\n%s\n%s\n", stmtins.m_sql, stmtins.m_cda.message);
                return false;
            }

            logfile.Write("sync %s to %s (%d rows) in %.2f sec\n", starg.fedtname, starg.localtname, ccount, Timer.Elapsed());

            connloc.commit();

            memset(keyvalues, 0, sizeof(keyvalues));

            ccount = 0;     // 记录从结果集中已经获取到的记录数

            PActive.UptATime();
        }
    }

    // 如果ccout大于0，表示还有没同步的记录，并且这些记录不够一批，那么就再执行一次同步
    if(ccount > 0)
    {
        // 从本地表中删除记录
        if(stmtdel.execute() != 0)
        {
            // 执行从本地表中删除记录的操作一般不会出错
            // 如果报错，就肯定是数据库的问题或者同步参数配置不正确，流程不必继续走下去
            logfile.Write("stmtdel.execute() failed\n%s\n%s\n", stmtdel.m_sql, stmtdel.m_cda.message);
            return false;
        }

        // 向本地表中插入记录
        if(stmtins.execute() != 0)
        {
            // 执行从本地表中插入记录的操作一般不会出错
            // 如果报错，就肯定是数据库的问题或者同步参数配置不正确，流程不必继续走下去
            logfile.Write("stmtins.execute() failed\n%s\n%s\n", stmtins.m_sql, stmtins.m_cda.message);
            return false;
        }

        logfile.Write("sync %s to %s (%d rows) in %.2f sec\n", starg.fedtname, starg.localtname, ccount, Timer.Elapsed());

        connloc.commit();

    }
    

    return true;
}

// 创建federated表的脚本
/*
create table LK_ZHOBTCODE1
(
   obtid                varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) not null comment '省名称',
   lat                  int not null comment '纬度，单位：0.01度。',
   lon                  int not null comment '经度，单位：0.01度。',
   height               int not null comment '海拔高度，单位：0.1米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (obtid),
   unique key ZHOBTCODE1_KEYID (keyid)
)ENGINE=FEDERATED CONNECTION='mysql://root:psaaword@192.168.31.133:3306/mysql/T_ZHOBTCODE1';

create table LK_ZHOBTMIND1
(
   obtid                varchar(10) not null comment '站点代码。',
   ddatetime            datetime not null comment '数据时间，精确到分钟。',
   t                    int comment '湿度，单位：0.1摄氏度。',
   p                    int comment '气压，单位：0.1百帕。',
   u                    int comment '相对湿度，0-100之间的值。',
   wd                   int comment '风向，0-360之间的值。',
   wf                   int comment '风速：单位0.1m/s。',
   r                    int comment '降雨量：0.1mm。',
   vis                  int comment '能见度：0.1米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                bigint not null auto_increment comment '记录编号，自动增长列。',
   primary key (obtid, ddatetime),
   unique key ZHOBTMIND1_KEYID (keyid)
)ENGINE=FEDERATED CONNECTION='mysql://root:psaaword@192.168.31.133:3306/mysql/T_ZHOBTMIND1';
*/
```
