# 刷新同步数据模块

- 全表刷新，使用于数据量不大的表，能保证数据的完整性
- 分批刷新，适用于数据量比较大的表，不能保证数据的完整性

建表1

```sql
drop table if exists T_ZHOBTCODE2;

/*==============================================================*/
/* Table: T_ZHOBTCODE2                                          */
/*==============================================================*/
create table T_ZHOBTCODE2
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE2_KEYID (keyid)
);

alter table T_ZHOBTCODE2 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```

建表2

```sql
drop table if exists T_ZHOBTCODE3;

/*==============================================================*/
/* Table: T_ZHOBTCODE3                                          */
/*==============================================================*/
create table T_ZHOBTCODE3
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE3_id (keyid)
);

alter table T_ZHOBTCODE3 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```



创建远程表 T_ZHOBTCODE1 的映射（federated）表 LK_ZHOBTCODE1

```sql
drop table if exists LK_ZHOBTCODE1;

/*==============================================================*/
/* Table: T_ZHOBTCODE1                                          */
/*==============================================================*/
create table LK_ZHOBTCODE1
(
   obtid                varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) not null comment '省名称',
   lat                  int not null comment '纬度，单位：0.01度。',
   lon                  int not null comment '经度，单位：0.01度。',
   height               int not null comment '海拔高度，单位：0.1米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (obtid),
   unique key ZHOBTCODE1_KEYID (keyid)
)engine=FEDERATED CONNECTION='mysql://root:sh269jgl105@192.168.31.133:3306/mysql/T_ZHOBTCODE1';
```

## 刷新同步-分批刷新

大致流程如下

1. 从远程表中查询需要同步的数据，把结果集分成若干批，每批的记录数在50-256之间
2. 删除本地表中指定批的记录
3. 把federated表中指定批的记录插入本地表

分批刷新同步的流程需要一个循环，在循环里面执行第二步和第三步，直到全部的数据被处理完。

其次，从远程表查询需要同步的数据，而不是federated表。为什么？一是federated表不支持普通索引，如果同步的条件不是主键，也不是唯一键，就会进行全表扫描，二是就算federated表支持索引，效率也不如直接访问远程表的效率高

