# 刷新同步数据模块

- 全表刷新，使用于数据量不大的表，能保证数据的完整性
- 分批刷新，适用于数据量比较大的表，不能保证数据的完整性

建表1

```sql
drop table if exists T_ZHOBTCODE2;

/*==============================================================*/
/* Table: T_ZHOBTCODE2                                          */
/*==============================================================*/
create table T_ZHOBTCODE2
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE2_KEYID (keyid)
);

alter table T_ZHOBTCODE2 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```

建表2

```sql
drop table if exists T_ZHOBTCODE3;

/*==============================================================*/
/* Table: T_ZHOBTCODE3                                          */
/*==============================================================*/
create table T_ZHOBTCODE3
(
   stid                 varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) comment '省名称',
   lat                  int comment '纬度，单位：0.01度。',
   lon                  int comment '经度，单位：0.01度。',
   altitude             numeric(8,2) comment '海拔高度，单位：米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (stid),
   unique key ZHOBTCODE3_id (keyid)
);

alter table T_ZHOBTCODE3 comment '本表用于syncupdate程序的测试，表结构与T_ZHOBTCODE略有不同。';

```

创建远程表 T_ZHOBTCODE1 的映射（federated）表 LK_ZHOBTCODE1

```sql
drop table if exists LK_ZHOBTCODE1;

/*==============================================================*/
/* Table: T_ZHOBTCODE1                                          */
/*==============================================================*/
create table LK_ZHOBTCODE1
(
   obtid                varchar(10) not null comment '站点代码',
   cityname             varchar(30) not null comment '城市名称',
   provname             varchar(30) not null comment '省名称',
   lat                  int not null comment '纬度，单位：0.01度。',
   lon                  int not null comment '经度，单位：0.01度。',
   height               int not null comment '海拔高度，单位：0.1米。',
   upttime              timestamp not null comment '更新时间。',
   keyid                int not null auto_increment comment '记录编号，自动增长列。',
   primary key (obtid),
   unique key ZHOBTCODE1_KEYID (keyid)
)engine=FEDERATED CONNECTION='mysql://root:sh269jgl105@192.168.31.133:3306/mysql/T_ZHOBTCODE1';
```

## 刷新同步-分批刷新

大致流程如下

1. 从远程表中查询需要同步的数据，把结果集分成若干批，每批的记录数在50-256之间
2. 删除本地表中指定批的记录
3. 把federated表中指定批的记录插入本地表

分批刷新同步的流程需要一个循环，在循环里面执行第二步和第三步，直到全部的数据被处理完。

其次，从远程表查询需要同步的数据，而不是federated表。为什么？一是federated表不支持普通索引，如果同步的条件不是主键，也不是唯一键，就会进行全表扫描，二是就算federated表支持索引，效率也不如直接访问远程表的效率高

```c++
// 业务处理主函数。
bool _syncupdate()
{
    CTimer Timer;

    sqlstatement stmtdel(&connloc);     // 执行删除本地表中记录的sql语句
    sqlstatement stmtins(&connloc);     // 执行向本地表中插入数据的sql语句

    // 如果是不分批同步，表示需要同步的数据量较少，执行一次sql语句就可以搞定（全表刷新）
    if(starg.synctype == 1)
    {
        logfile.Write("sync %s to %s ....", starg.fedtname, starg.localtname);

        // 先删除starg.localtname表中满足where条件的记录
        stmtdel.prepare("delete from %s %s", starg.localtname, starg.where);
        if(stmtdel.execute() != 0)
        {
            logfile.Write("stmtdel.execute() failed\n%s\n%s\n", stmtdel.m_sql, stmtdel.m_cda.message);
            return false;
        }
        // 再把starg.fedtname表中满足where条件的记录插入到starg.localname表中
        stmtins.prepare("insert into %s(%s) select %s from %s %s", starg.localtname, starg.localcols, starg.remotecols, starg.fedtname, starg.where);
        if(stmtins.execute() != 0)
        {
            // 如果执行插入sql失败，那么应该回滚事务
            connloc.rollback();

            logfile.Write("stmtins.execute() failed\n%s\n%s\n", stmtins.m_sql, stmtins.m_cda.message);

            return false;
        }
        
        logfile.WriteEx("   %d rows in %.2f sec\n", stmtins.m_cda.rpc, Timer.Elapsed());

        connloc.commit();   // 提交事务
        return true;
    }

    return true;
}
```

如下图所示是我们手工同步需要执行的sql语句。在项目开发过程中，其实要拼接执行的sql语句也就是这样

![](./img/QQ截图20220420202342.png)

这里对同步刷新（全表刷新）做一下测试。编译运行，先看无条件同步（下图中分别执行了两次程序，第一次是无条件全表同步，第二次可以看到我们带了where条件语句，值同步广东省的站点参数）

![](./img/QQ截图20220420202242.png)

然后看执行日志，可以看到全表800多条记录全部被同步进t_zhobtcode2表中

![](./img/QQ截图20220420201917.png)

查看表结果

![](./img/QQ截图20220420201824.png)

然后再看条件同步的结果，先看日志

![](./img/QQ截图20220420202214.png)

然后是同步结果，可以看到，确实只有广东的站点数据被同步了

![](./img/QQ截图20220420202300.png)
