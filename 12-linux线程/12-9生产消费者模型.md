# 生产消费者模型

## 生产消费者模型的基本概念

![](./img/QQ截图20220501201238.png)

如图所示，多个生产者生产数据，放在共享的缓存队列中，消费者从缓存队列中获取数据并进行数据处理。图中的生产者和消费者对应了进程或者线程。如果生产者和消费者是不同程序中的进程或者线程，可以用共享内存来做缓存。如果生产者和消费是同一个程序中的多个线程，直接动态的分配一块内存出来就行。

生产者和消费者都要操作共享的缓存队列，肯定会有竞争，所以要给缓存加锁。除此之外，生产者在生成了数据之后，要通知消费者去取走消费数据。

在多线程中，最常见的是用互斥锁+条件变量实现生产消费者模型。互斥锁用于给缓存加锁，条件变量用于通知消费者去取走数据。

也可以用两个信号量去实现生产消费者模型，一个用于共享内存加锁，另一个用于通知消费者

## 互斥锁+条件变量实现生产消费者模型

在讲生产消费者模型之前，先看条件变量的wait函数

```c++
       int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                                  pthread_mutex_t *restrict mutex,
                                  const struct timespec *restrict abstime);
       int pthread_cond_wait(pthread_cond_t *restrict cond,
                             pthread_mutex_t *restrict mutex);

```

wait函数里面做了3件事情

- 把互斥锁进行解锁
- 阻塞，等待条件信号（被唤醒），如果条件信号一直不到达，就一直阻塞卡住等待。
- 如果条件信号出现了，就给互斥锁加锁（条件信号触发，给互斥锁加锁）

## 信号量实现生产消费者模型
