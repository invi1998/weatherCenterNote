# 线程同步

## 互斥锁

- 互斥锁，只有加锁和解锁两种状态，确保同一时间只有一个线程可以访问共享资源
- 线程在访问共享资源之前申请加锁，加锁成功之后访问共享资源，访问玩之后释放锁
- 如果某线程持有锁，其他的线程会形成等待队列

线程同步-互斥锁

- `pthread_mutex_t mutex;`    // 声明锁
- `int pthread_mutex_init();`    // 初始化锁
- `int pthread_mutex_lock();`    // 等待并加锁
- `int pthread_mutex_trylock();`   // 尝试加锁，不等待
- `int pthread_mutex_timedlock();`  // 带超时机制的加锁
- `int pthread_mutex_unlock();`    // 解锁
- `int pthread_mutex_destroy();`    // 销毁锁

声明并初始化互斥锁有如下两种方式

```c++
pthread_mutex_t mutexvar = PTHREAD_MUTEX_INITIALIZER;           // 声明互斥锁
```

或者

```c++
pthread_mutex_t mutexvar;           // 声明互斥锁
...
pthread_mutex_init(&mutexvar, NULL);        // 初始化锁
```

这两种互斥锁声明方式是一样的。

### 互斥锁的属性

- `PTHREAD_MUTEX_TIMED_NP`，这是缺省值，也就是普通锁，当一个线程加锁之后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性
- `PTHREAD_MUTEX_RECURSIVE_NP`，嵌套锁（递归锁），允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁，如果是不同线程请求，则在加锁线程解锁时重新竞争
- `PTHREAD_MUTEX_ADAPTIVE_NP`，适应锁，解锁之后，请求锁的线程重新竞争

```c++
// 线程参数传递
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

// 线程入口函数
void * thmain(void * arg);

int var = 0;

pthread_mutex_t mutexvar = PTHREAD_MUTEX_INITIALIZER;           // 声明互斥锁

int main(int argc, char* argv[])
{
    // pthread_mutex_init(&mutexvar, NULL);        // 初始化锁

    pthread_t thid1=0, thid2 = 0;

    // 创建线程（将线程属性作为参数传递给创建线程函数）
    if(pthread_create(&thid1, NULL, thmain, NULL) != 0)
    {
        printf("线程创建失败\n");
        exit(-1);
    }

    if(pthread_create(&thid2, NULL, thmain, NULL) != 0)
    {
        printf("线程创建失败\n");
        exit(-1);
    }

    // 等待子线程退出
    printf("join...\n");
    pthread_join(thid1, NULL);
    pthread_join(thid2, NULL);
    printf("join-ok\n");
    printf("var = %d\n", var);

    pthread_mutex_destroy(&mutexvar);
}

void * thmain(void * arg)
{
    pthread_mutex_lock(&mutexvar);
    for(int i = 0; i< 100000; i++)
    {
        var++;
    }
    pthread_mutex_unlock(&mutexvar);

    return (void*)10;
}

```

编译运行

![](./img/QQ截图20220501140943.png)

## 自旋锁

- `pthread_spinlock_t mutex;`			// 声明锁
- `int pthread_spin_init();`				// 初始化锁
- `int pthread_spin_lock();`				// 等待加锁
- `int pthread_spin_trylock();`			// 尝试加锁，不等待
- `int pthread_spin_unlock();`			 // 解锁
- `int pthread_spin_destroy();`			// 销毁锁

自旋锁的功能和互斥锁是一样的，不同的是，互斥锁在等待的时候线程会休眠，不消耗CPU资源，而自旋锁不一样，它用一个循环不断的检测锁是否可用，会消耗CPU。自旋锁适用于等待时间很短的场景，而互斥锁适用于等待时间可能会比较长的场景。

自旋锁没有带超时机制的锁函数，因为使用自旋锁有一个前提条件，就是假设你等待时间会很短，不应该等待很长时间。

自旋锁的初始化只能用函数，不能和互斥锁一样，在声明的是就进行属性初始化。此外，自旋锁的初始化函数和互斥锁还有点不同，就是，他的第二个参数，是一个共享标志。这个标志的意思其实就是标识在多进程程序中，如果创建了多线程，不同进程之间的线程是否可以共享自旋锁。这个参数一般填 `PTHREAD_PROCESS_PRIVATE`（私有的，多进程间不共享）

```c++
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
```

`PTHREAD_PROCESS_SHARED`：表示在多个进程的线程之间可以共享

`PTHREAD_PROCESS_PRIVATE`：表示只能在初始化本自旋锁的进程的线程间才能使用该线程锁。

```c++
// 线程参数传递
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

// 线程入口函数
void * thmain(void * arg);

int var = 0;

pthread_spinlock_t spin;           // 声明自旋锁

int main(int argc, char* argv[])
{
    pthread_spin_init(&spin, PTHREAD_PROCESS_PRIVATE);        // 初始化锁

    pthread_t thid1=0, thid2 = 0;

    // 创建线程（将线程属性作为参数传递给创建线程函数）
    if(pthread_create(&thid1, NULL, thmain, NULL) != 0)
    {
        printf("线程创建失败\n");
        exit(-1);
    }

    if(pthread_create(&thid2, NULL, thmain, NULL) != 0)
    {
        printf("线程创建失败\n");
        exit(-1);
    }

    // 等待子线程退出
    printf("join...\n");
    pthread_join(thid1, NULL);
    pthread_join(thid2, NULL);
    printf("join-ok\n");
    printf("var = %d\n", var);

    pthread_spin_destroy(&spin);
}

void * thmain(void * arg)
{
    for(int i = 0; i< 100000; i++)
    {
        pthread_spin_lock(&spin);
        var++;
        pthread_spin_unlock(&spin);
    }

    return (void*)10;
}

```



## 读写锁



## 条件变量

## 信号量

## 生产消费者模型
